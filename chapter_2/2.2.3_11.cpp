/* **************************************************
 * Filename: 2.2.3_11.cpp
 *   Create: 2022-05-28
 *   Author: Wulnut
 * *************************************************/
/**
 * 分别求两个升序序列A、B的中位数，设为a和b。
 * 1.若a=b，则a或b即为所求的中位数，算法结束。
 * 2.若a<b，舍弃A中较小者所在序列之较小一半，同时舍弃B所在序列之较大一半，要求两次舍弃的元素个数相同。
 * 3.若a>b，舍弃B中较小者所在序列之较小一半，同时舍弃A所在序列之较大一半，要求两次舍弃的元素个数相同。
 * 在保留的两个升序序列中，重复上述过程，直到两个序列中均只含一个元素时为止，则较小者即为所求的中位数。
 *
 *    若a<b时，中位数则肯定不在A的左半边，因为如果在A的左半边则中位数<a<b，即也在B的左半边，在整个S1+S2
 * 中也是在左半边，不是在中点，与中位数矛盾；同理不在B的右半边。
 *    若a>b时，原理同上。当A长度为奇数时，左半边=右半边，直接舍弃即可当A长度为偶数时，左半边+1=右半边。
 * 若a<b，舍弃A的左半边(包括中点) 舍弃B的右半边(保留中点）始终保持A,B比较项数相同，即等长
 */

#include <iostream>
using namespace std;

//寻找两个有序数组的中位数
int middle_search(int A[], int B[], int n)
{
    int m1, m2, s1, s2, d1, d2;
    s1 = s2 = 0;
    d1 = d2 = n - 1;
    while (s1 != d1 || s2 != d2)
    {
        m1 = (s1 + d1) / 2;
        m2 = (s2 + d2) / 2;
        if (A[m1] == B[m2])
            return A[m1];
        if (A[m1] < B[m2])//A的中位数比B的中位数小
        {
            if ((s1 + d1) % 2 == 0)//当前比较元素为奇数
            {
                s1 = m1;//A的比较范围向后移动,保留中间点
            } else {
                s1 = m1 + 1;//A的比较范围向后移动,不保留中间点
            }
            d2 = m2;//B的比较范围向前移动,保留中间点
        } else {//A的中位数比B的中位数大
            d1 = m1;//A的比较范围向前移动,保留中间点
            if ((s2 + d2) % 2 == 0)//当前比较元素为偶数
            {
                s2 = m2;//B的比较范围向后移动,保留中间点
            } else {
                s2 = m2 + 1;//B的比较范围向后移动,保留中间点
            }
        }
    }
    if (A[s1] < B[s2])//取小即为中位数点
        return A[s1];
    else return B[s2];

}

int main() {
    int A[] = {11, 13, 15, 17, 19};
    int B[] = {2, 4, 6, 8, 20};
    int mid = middle_search(A, B, 5);
    printf("%d", mid);
    return 0;
}